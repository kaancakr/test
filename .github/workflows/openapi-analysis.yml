name: OpenAPI Analysis (Self-Contained)

on:
  push:
    branches: [ main, develop ]
    paths:
      - '**/*.json'
      - '**/*.yaml'
      - '**/*.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - '**/*.json'
      - '**/*.yaml'
      - '**/*.yml'
  workflow_dispatch:

jobs:
  analyze-openapi:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install requests PyYAML openapi-spec-validator
        
    - name: Create analyzer script
      run: |
        cat > analyzer.py << 'EOF'
        import json
        import os
        import sys
        import requests
        import yaml
        import argparse
        from typing import Any, Dict, List, Optional, Tuple
        from urllib.parse import urljoin

        def _load_openapi_from_bytes(data: bytes) -> Tuple[Optional[dict], List[str]]:
            suggestions: List[str] = []
            text = data.decode("utf-8", errors="replace").strip()

            loaded: Optional[dict] = None
            try:
                loaded = json.loads(text)
            except json.JSONDecodeError:
                try:
                    loaded = yaml.safe_load(text)
                except yaml.YAMLError as e:
                    suggestions.append(f"Failed to parse as JSON or YAML: {e}")
                    loaded = None

            if not isinstance(loaded, dict):
                suggestions.append("OpenAPI content is not a valid JSON/YAML object.")
                return None, suggestions

            return loaded, suggestions

        def analyze_openapi_spec(spec: dict) -> Dict[str, Any]:
            suggestions: List[str] = []
            
            info = spec.get("info", {})
            if not info.get("title"):
                suggestions.append("Spec is missing an API title.")
            if not info.get("description"):
                suggestions.append("Spec should include a description.")
            if not info.get("version"):
                suggestions.append("Spec should define an API version.")

            openapi_version = spec.get("openapi") or spec.get("swagger")
            paths = spec.get("paths") or {}
            components = spec.get("components", {})
            schemas = components.get("schemas", {}) if isinstance(components, dict) else {}

            servers = spec.get("servers", [])
            if not servers:
                suggestions.append("No servers defined. Consider specifying servers for clarity.")

            security = spec.get("security", [])
            if not security:
                suggestions.append("No global security requirements defined. Consider adding authentication info.")
            
            security_schemes = components.get("securitySchemes", {})
            if isinstance(security_schemes, dict):
                if not security_schemes:
                    suggestions.append("No security schemes defined in components.")

            operations_count = sum(
                1 for path, methods in (paths or {}).items() if isinstance(methods, dict)
                for method in methods.keys() if method.lower() in [
                    "get", "post", "put", "delete", "patch", "options", "head", "trace"
                ]
            )

            for path, methods in paths.items():
                if not isinstance(methods, dict):
                    continue
                for method, details in methods.items():
                    if method.lower() not in [
                        "get", "post", "put", "delete", "patch", "options", "head", "trace"
                    ]:
                        continue
                    if not isinstance(details, dict):
                        continue

                    opid = details.get("operationId")
                    if not opid:
                        suggestions.append(f"Operation {method.upper()} {path} missing operationId.")

                    if not details.get("summary"):
                        suggestions.append(f"Operation {method.upper()} {path} missing summary.")
                    if not details.get("description"):
                        suggestions.append(f"Operation {method.upper()} {path} missing description.")
                    
                    if not details.get("tags"):
                        suggestions.append(f"Operation {method.upper()} {path} missing tags for grouping.")

                    method_lower = method.lower()
                    if method_lower == "get" and "requestBody" in details:
                        suggestions.append(f"GET operation {path} should not have requestBody.")
                    elif method_lower in ["post", "put", "patch"] and "requestBody" not in details:
                        suggestions.append(f"{method.upper()} operation {path} should have requestBody.")
                    elif method_lower == "delete" and "requestBody" in details:
                        suggestions.append(f"DELETE operation {path} typically should not have requestBody.")

                    responses = details.get("responses", {})
                    if not responses:
                        suggestions.append(f"Operation {method.upper()} {path} has no responses defined.")
                    else:
                        if "200" not in responses and "201" not in responses:
                            suggestions.append(
                                f"Operation {method.upper()} {path} missing 200/201 success response."
                            )
                        
                        has_4xx = any(code.startswith("4") for code in responses.keys())
                        has_5xx = any(code.startswith("5") for code in responses.keys())
                        if not has_4xx:
                            suggestions.append(f"Operation {method.upper()} {path} missing 4xx error responses.")
                        if not has_5xx:
                            suggestions.append(f"Operation {method.upper()} {path} missing 5xx error responses.")

            return {
                "status": "success",
                "is_valid": True,
                "summary": {
                    "openapi_version": str(openapi_version) if openapi_version else None,
                    "paths_count": len(paths) if isinstance(paths, dict) else 0,
                    "operations_count": operations_count,
                    "schemas_count": len(schemas) if isinstance(schemas, dict) else 0,
                },
                "suggestions": suggestions,
            }

        def analyze_local_file(file_path: str) -> Dict[str, Any]:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                spec, parse_suggestions = _load_openapi_from_bytes(content.encode('utf-8'))
                
                if spec:
                    result = analyze_openapi_spec(spec)
                    result["file_path"] = file_path
                    return result
                else:
                    return {
                        "status": "error",
                        "message": "Failed to parse OpenAPI spec",
                        "suggestions": parse_suggestions,
                        "file_path": file_path
                    }
            except FileNotFoundError:
                return {
                    "status": "error",
                    "message": f"File not found: {file_path}",
                    "file_path": file_path
                }
            except Exception as e:
                return {
                    "status": "error",
                    "message": f"Error reading file: {e}",
                    "file_path": file_path
                }

        def main():
            if len(sys.argv) < 2:
                print("Usage: python analyzer.py <file-path>")
                sys.exit(1)
            
            file_path = sys.argv[1]
            result = analyze_local_file(file_path)
            print(json.dumps(result, indent=2))

        if __name__ == "__main__":
            main()
        EOF
        
    - name: Run OpenAPI Analysis
      id: analyze
      run: |
        python analyzer.py test-swagger.json > analysis-results.json
        echo "analysis<<EOF" >> $GITHUB_OUTPUT
        cat analysis-results.json >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Extract individual values for outputs
        is_valid=$(python -c "import json; data=json.load(open('analysis-results.json')); print(data.get('is_valid', False))")
        suggestions_count=$(python -c "import json; data=json.load(open('analysis-results.json')); print(len(data.get('suggestions', [])))")
        operations_count=$(python -c "import json; data=json.load(open('analysis-results.json')); print(data.get('summary', {}).get('operations_count', 0))")
        paths_count=$(python -c "import json; data=json.load(open('analysis-results.json')); print(data.get('summary', {}).get('paths_count', 0))")
        schemas_count=$(python -c "import json; data=json.load(open('analysis-results.json')); print(data.get('summary', {}).get('schemas_count', 0))")
        
        echo "is_valid=$is_valid" >> $GITHUB_OUTPUT
        echo "suggestions_count=$suggestions_count" >> $GITHUB_OUTPUT
        echo "operations_count=$operations_count" >> $GITHUB_OUTPUT
        echo "paths_count=$paths_count" >> $GITHUB_OUTPUT
        echo "schemas_count=$schemas_count" >> $GITHUB_OUTPUT
        
    - name: Upload analysis results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: openapi-analysis-results
        path: analysis-results.json
        retention-days: 30
        
    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = JSON.parse('${{ steps.analyze.outputs.analysis }}');
          const comment = `## 🔍 OpenAPI Analysis Results
          
          **Valid**: ${analysis.is_valid ? '✅' : '❌'}
          **Suggestions**: ${analysis.suggestions ? analysis.suggestions.length : 0}
          **Operations**: ${analysis.summary ? analysis.summary.operations_count : 0}
          **Paths**: ${analysis.summary ? analysis.summary.paths_count : 0}
          **Schemas**: ${analysis.summary ? analysis.summary.schemas_count : 0}
          
          ${analysis.suggestions && analysis.suggestions.length > 0 ? 
            `### 📋 Top Suggestions:\n\n${analysis.suggestions.slice(0, 5).map(s => `- ${s}`).join('\n')}` : 
            '### ✅ No suggestions found! Your OpenAPI specification looks great! 🎉'
          }
          
          Detailed results are available in the workflow artifacts.`;
            
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
